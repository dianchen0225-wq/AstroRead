/**
 * SecurityUtils å•å…ƒæµ‹è¯•
 * æµ‹è¯•è·¯å¾„å®‰å…¨ã€è¾“å…¥éªŒè¯ç­‰æ ¸å¿ƒå®‰å…¨åŠŸèƒ½
 */

import { SecurityUtils } from '../SecurityUtils';
import { PathValidationResult } from '../SecurityUtils';

export class SecurityUtilsTest {
  private passed: number = 0;
  private failed: number = 0;

  /**
   * æµ‹è¯•è·¯å¾„éå†æ”»å‡»é˜²æŠ¤
   */
  testPathTraversalPrevention(): boolean {
    const testCases = [
      { input: '../../../etc/passwd', shouldBeValid: false, description: 'ä¸Šçº§ç›®å½•éå†' },
      { input: '..\\..\\windows\\system32', shouldBeValid: false, description: 'Windowsä¸Šçº§ç›®å½•éå†' },
      { input: '/etc/passwd', shouldBeValid: false, description: 'ç»å¯¹è·¯å¾„' },
      { input: 'C:\\Windows\\System32', shouldBeValid: false, description: 'Windowsç»å¯¹è·¯å¾„' },
      { input: 'normal_file.txt', shouldBeValid: true, description: 'æ­£å¸¸æ–‡ä»¶å' },
      { input: 'path/to/file.txt', shouldBeValid: true, description: 'æ­£å¸¸ç›¸å¯¹è·¯å¾„' },
      { input: 'file%2F..%2Fetc', shouldBeValid: false, description: 'URLç¼–ç éå†' },
      { input: 'file\x00.txt', shouldBeValid: false, description: 'ç©ºå­—èŠ‚æ³¨å…¥' },
    ];

    let allPassed = true;

    for (const testCase of testCases) {
      const result = SecurityUtils.validatePath(testCase.input);
      const isValid = result === PathValidationResult.VALID;

      if (isValid !== testCase.shouldBeValid) {
        console.error(`âŒ testPathTraversalPrevention: ${testCase.description}`);
        console.error(`   æœŸæœ›: ${testCase.shouldBeValid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}, å®é™…: ${isValid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}`);
        this.failed++;
        allPassed = false;
      } else {
        console.log(`âœ… ${testCase.description}`);
      }
    }

    if (allPassed) {
      this.passed++;
      console.log('âœ… testPathTraversalPrevention passed');
    }

    return allPassed;
  }

  /**
   * æµ‹è¯•æ–‡ä»¶åæ¸…ç†
   */
  testSanitizeFilename(): boolean {
    const testCases = [
      { input: 'file<name>.txt', expected: 'file_name_.txt', description: 'ç§»é™¤å°–æ‹¬å·' },
      { input: 'file:name|*.txt', expected: 'file_name_.txt', description: 'ç§»é™¤Windowséæ³•å­—ç¬¦' },
      { input: 'normal.txt', expected: 'normal.txt', description: 'æ­£å¸¸æ–‡ä»¶å' },
      { input: '../../../etc/passwd', expected: '________etc_passwd', description: 'æ¸…ç†è·¯å¾„éå†' },
      { input: 'file\x00.txt', expected: 'file_.txt', description: 'ç§»é™¤ç©ºå­—èŠ‚' },
    ];

    let allPassed = true;

    for (const testCase of testCases) {
      const result = SecurityUtils.sanitizeFilename(testCase.input);

      if (result !== testCase.expected) {
        console.error(`âŒ testSanitizeFilename: ${testCase.description}`);
        console.error(`   æœŸæœ›: "${testCase.expected}", å®é™…: "${result}"`);
        this.failed++;
        allPassed = false;
      } else {
        console.log(`âœ… ${testCase.description}`);
      }
    }

    if (allPassed) {
      this.passed++;
      console.log('âœ… testSanitizeFilename passed');
    }

    return allPassed;
  }

  /**
   * æµ‹è¯•è¾“å…¥éªŒè¯
   */
  testValidateInput(): boolean {
    const testCases = [
      { input: 'normal input', min: 1, max: 100, pattern: undefined, shouldBeValid: true, description: 'æ­£å¸¸è¾“å…¥' },
      { input: '', min: 1, max: 100, pattern: undefined, shouldBeValid: false, description: 'ç©ºå­—ç¬¦ä¸²' },
      { input: 'a'.repeat(101), min: 1, max: 100, pattern: undefined, shouldBeValid: false, description: 'è¶…é•¿å­—ç¬¦ä¸²' },
      { input: 'test123', min: 1, max: 100, pattern: /^[a-z0-9]+$/, shouldBeValid: true, description: 'åŒ¹é…æ­£åˆ™' },
      { input: 'TEST123', min: 1, max: 100, pattern: /^[a-z0-9]+$/, shouldBeValid: false, description: 'ä¸åŒ¹é…æ­£åˆ™' },
    ];

    let allPassed = true;

    for (const testCase of testCases) {
      const result = SecurityUtils.validateInput(
        testCase.input,
        testCase.min,
        testCase.max,
        testCase.pattern
      );

      if (result !== testCase.shouldBeValid) {
        console.error(`âŒ testValidateInput: ${testCase.description}`);
        console.error(`   æœŸæœ›: ${testCase.shouldBeValid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}, å®é™…: ${result ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}`);
        this.failed++;
        allPassed = false;
      } else {
        console.log(`âœ… ${testCase.description}`);
      }
    }

    if (allPassed) {
      this.passed++;
      console.log('âœ… testValidateInput passed');
    }

    return allPassed;
  }

  /**
   * æµ‹è¯•SQLæ³¨å…¥é˜²æŠ¤
   */
  testSqlInjectionPrevention(): boolean {
    const testCases = [
      { input: "'; DROP TABLE users; --", shouldBeSafe: false, description: 'ç»å…¸SQLæ³¨å…¥' },
      { input: "1 OR 1=1", shouldBeSafe: false, description: 'å¸ƒå°”æ³¨å…¥' },
      { input: "1; DELETE FROM users", shouldBeSafe: false, description: 'å †å æŸ¥è¯¢' },
      { input: "normal_value", shouldBeSafe: true, description: 'æ­£å¸¸å€¼' },
      { input: "user@example.com", shouldBeSafe: true, description: 'é‚®ç®±åœ°å€' },
    ];

    let allPassed = true;

    for (const testCase of testCases) {
      const isSafe = SecurityUtils.isSafeSqlInput(testCase.input);

      if (isSafe !== testCase.shouldBeSafe) {
        console.error(`âŒ testSqlInjectionPrevention: ${testCase.description}`);
        console.error(`   æœŸæœ›: ${testCase.shouldBeSafe ? 'å®‰å…¨' : 'ä¸å®‰å…¨'}, å®é™…: ${isSafe ? 'å®‰å…¨' : 'ä¸å®‰å…¨'}`);
        this.failed++;
        allPassed = false;
      } else {
        console.log(`âœ… ${testCase.description}`);
      }
    }

    if (allPassed) {
      this.passed++;
      console.log('âœ… testSqlInjectionPrevention passed');
    }

    return allPassed;
  }

  /**
   * æµ‹è¯•XSSé˜²æŠ¤
   */
  testXssPrevention(): boolean {
    const testCases = [
      { input: '<script>alert(1)</script>', shouldBeSafe: false, description: 'è„šæœ¬æ ‡ç­¾' },
      { input: 'javascript:alert(1)', shouldBeSafe: false, description: 'JavaScriptåè®®' },
      { input: '<img src=x onerror=alert(1)>', shouldBeSafe: false, description: 'äº‹ä»¶å¤„ç†å™¨' },
      { input: 'normal text', shouldBeSafe: true, description: 'æ­£å¸¸æ–‡æœ¬' },
      { input: 'https://example.com', shouldBeSafe: true, description: 'æ­£å¸¸URL' },
    ];

    let allPassed = true;

    for (const testCase of testCases) {
      const isSafe = SecurityUtils.isSafeXssInput(testCase.input);

      if (isSafe !== testCase.shouldBeSafe) {
        console.error(`âŒ testXssPrevention: ${testCase.description}`);
        console.error(`   æœŸæœ›: ${testCase.shouldBeSafe ? 'å®‰å…¨' : 'ä¸å®‰å…¨'}, å®é™…: ${isSafe ? 'å®‰å…¨' : 'ä¸å®‰å…¨'}`);
        this.failed++;
        allPassed = false;
      } else {
        console.log(`âœ… ${testCase.description}`);
      }
    }

    if (allPassed) {
      this.passed++;
      console.log('âœ… testXssPrevention passed');
    }

    return allPassed;
  }

  /**
   * æµ‹è¯•URLå®‰å…¨éªŒè¯
   */
  testUrlValidation(): boolean {
    const testCases = [
      { url: 'http://example.com', shouldBeValid: true, description: 'HTTP URL' },
      { url: 'https://example.com', shouldBeValid: true, description: 'HTTPS URL' },
      { url: 'ftp://example.com', shouldBeValid: false, description: 'FTP URL' },
      { url: 'file:///etc/passwd', shouldBeValid: false, description: 'æ–‡ä»¶åè®®' },
      { url: 'http://192.168.1.1', shouldBeValid: false, description: 'å†…ç½‘IP' },
      { url: 'http://localhost:8080', shouldBeValid: false, description: 'æœ¬åœ°ä¸»æœº' },
      { url: 'not-a-url', shouldBeValid: false, description: 'æ— æ•ˆURL' },
    ];

    let allPassed = true;

    for (const testCase of testCases) {
      const result = SecurityUtils.validateUrl(testCase.url);
      const isValid = result === PathValidationResult.VALID;

      if (isValid !== testCase.shouldBeValid) {
        console.error(`âŒ testUrlValidation: ${testCase.description}`);
        console.error(`   æœŸæœ›: ${testCase.shouldBeValid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}, å®é™…: ${isValid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}`);
        this.failed++;
        allPassed = false;
      } else {
        console.log(`âœ… ${testCase.description}`);
      }
    }

    if (allPassed) {
      this.passed++;
      console.log('âœ… testUrlValidation passed');
    }

    return allPassed;
  }

  /**
   * è¿è¡Œæ‰€æœ‰æµ‹è¯•
   */
  async runAllTests(): Promise<boolean> {
    console.log('ğŸš€ Starting SecurityUtils tests...\n');

    this.testPathTraversalPrevention();
    this.testSanitizeFilename();
    this.testValidateInput();
    this.testSqlInjectionPrevention();
    this.testXssPrevention();
    this.testUrlValidation();

    const total: number = this.passed + this.failed;
    console.log(`\nğŸ“Š Test Results: ${this.passed}/${total} tests passed`);

    if (this.failed > 0) {
      console.log(`âŒ ${this.failed} tests failed`);
    } else {
      console.log('âœ… All tests passed!');
    }

    return this.failed === 0;
  }
}

// å¯¼å‡ºæµ‹è¯•å®ä¾‹
const securityUtilsTest: SecurityUtilsTest = new SecurityUtilsTest();
export default securityUtilsTest;
