/**
 * Semaphore å•å…ƒæµ‹è¯•
 * æµ‹è¯•ä¿¡å·é‡å¹¶å‘æ§åˆ¶åŠŸèƒ½
 */

import { Semaphore, ReadWriteLock, ConcurrencyController, SemaphoreStats } from '../performance/Semaphore';

export class SemaphoreTest {
  passed: number = 0;
  failed: number = 0;

  /**
   * æµ‹è¯•åŸºæœ¬ä¿¡å·é‡åŠŸèƒ½
   */
  async testBasicSemaphore(): Promise<boolean> {
    const semaphore: Semaphore = new Semaphore({ permits: 2, name: 'test-basic' });

    try {
      // æµ‹è¯•åˆå§‹çŠ¶æ€
      if (semaphore.availablePermits() !== 2) {
        console.error('âŒ testBasicSemaphore: åˆå§‹è®¸å¯æ•°é”™è¯¯');
        this.failed++;
        return false;
      }

      // æµ‹è¯•è·å–è®¸å¯
      await semaphore.acquire();
      if (semaphore.availablePermits() !== 1) {
        console.error('âŒ testBasicSemaphore: è·å–è®¸å¯åæ•°é‡é”™è¯¯');
        this.failed++;
        return false;
      }

      // æµ‹è¯•é‡Šæ”¾è®¸å¯
      semaphore.release();
      if (semaphore.availablePermits() !== 2) {
        console.error('âŒ testBasicSemaphore: é‡Šæ”¾è®¸å¯åæ•°é‡é”™è¯¯');
        this.failed++;
        return false;
      }

      console.log('âœ… testBasicSemaphore passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testBasicSemaphore: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * æµ‹è¯•ä¿¡å·é‡é˜»å¡
   */
  async testSemaphoreBlocking(): Promise<boolean> {
    const semaphore: Semaphore = new Semaphore({ permits: 1, name: 'test-blocking' });

    try {
      // è·å–å”¯ä¸€è®¸å¯
      await semaphore.acquire();

      // å°è¯•éé˜»å¡è·å–ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
      const acquired: boolean = semaphore.tryAcquire();
      if (acquired) {
        console.error('âŒ testSemaphoreBlocking: åº”è¯¥æ— æ³•è·å–è®¸å¯');
        this.failed++;
        return false;
      }

      // é‡Šæ”¾è®¸å¯
      semaphore.release();

      // ç°åœ¨åº”è¯¥å¯ä»¥è·å–
      const acquired2: boolean = semaphore.tryAcquire();
      if (!acquired2) {
        console.error('âŒ testSemaphoreBlocking: åº”è¯¥å¯ä»¥è·å–è®¸å¯');
        this.failed++;
        return false;
      }

      semaphore.release();

      console.log('âœ… testSemaphoreBlocking passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testSemaphoreBlocking: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * æµ‹è¯•å¸¦è¶…æ—¶çš„è·å–
   */
  async testTryAcquireWithTimeout(): Promise<boolean> {
    const semaphore: Semaphore = new Semaphore({ permits: 1, name: 'test-timeout' });

    try {
      // è·å–å”¯ä¸€è®¸å¯
      await semaphore.acquire();

      // å°è¯•å¸¦è¶…æ—¶çš„è·å–ï¼ˆåº”è¯¥è¶…æ—¶ï¼‰
      const startTime: number = Date.now();
      const acquired: boolean = await semaphore.tryAcquireWithTimeout(100);
      const endTime: number = Date.now();

      if (acquired) {
        console.error('âŒ testTryAcquireWithTimeout: åº”è¯¥è¶…æ—¶');
        this.failed++;
        return false;
      }

      if (endTime - startTime < 90 || endTime - startTime > 200) {
        console.error(`âŒ testTryAcquireWithTimeout: è¶…æ—¶æ—¶é—´ä¸å‡†ç¡® (${endTime - startTime}ms)`);
        this.failed++;
        return false;
      }

      // é‡Šæ”¾å¹¶é‡æ–°è·å–
      semaphore.release();
      const acquired2: boolean = await semaphore.tryAcquireWithTimeout(100);
      if (!acquired2) {
        console.error('âŒ testTryAcquireWithTimeout: åº”è¯¥æˆåŠŸè·å–');
        this.failed++;
        return false;
      }

      semaphore.release();

      console.log('âœ… testTryAcquireWithTimeout passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testTryAcquireWithTimeout: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * æµ‹è¯•executeæ–¹æ³•
   */
  async testExecute(): Promise<boolean> {
    const semaphore: Semaphore = new Semaphore({ permits: 1, name: 'test-execute' });
    let executed: boolean = false;

    try {
      const result: string = await semaphore.execute(async () => {
        executed = true;
        return 'success';
      });

      if (!executed) {
        console.error('âŒ testExecute: å‡½æ•°æœªæ‰§è¡Œ');
        this.failed++;
        return false;
      }

      if (result !== 'success') {
        console.error('âŒ testExecute: è¿”å›å€¼é”™è¯¯');
        this.failed++;
        return false;
      }

      // éªŒè¯è®¸å¯å·²é‡Šæ”¾
      if (semaphore.availablePermits() !== 1) {
        console.error('âŒ testExecute: è®¸å¯æœªé‡Šæ”¾');
        this.failed++;
        return false;
      }

      console.log('âœ… testExecute passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testExecute: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * æµ‹è¯•æ‰¹é‡æ“ä½œ
   */
  async testBatchOperations(): Promise<boolean> {
    const semaphore: Semaphore = new Semaphore({ permits: 3, name: 'test-batch' });

    try {
      // æ‰¹é‡è·å–
      await semaphore.acquireMany(2);
      if (semaphore.availablePermits() !== 1) {
        console.error('âŒ testBatchOperations: æ‰¹é‡è·å–åæ•°é‡é”™è¯¯');
        this.failed++;
        return false;
      }

      // æ‰¹é‡é‡Šæ”¾
      semaphore.releaseMany(2);
      if (semaphore.availablePermits() !== 3) {
        console.error('âŒ testBatchOperations: æ‰¹é‡é‡Šæ”¾åæ•°é‡é”™è¯¯');
        this.failed++;
        return false;
      }

      console.log('âœ… testBatchOperations passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testBatchOperations: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * æµ‹è¯•åŠ¨æ€è°ƒæ•´è®¸å¯æ•°
   */
  async testDynamicPermits(): Promise<boolean> {
    const semaphore: Semaphore = new Semaphore({ permits: 2, name: 'test-dynamic' });

    try {
      // å‡å°‘è®¸å¯
      semaphore.reducePermits(1);
      if (semaphore.availablePermits() !== 1) {
        console.error('âŒ testDynamicPermits: å‡å°‘è®¸å¯åæ•°é‡é”™è¯¯');
        this.failed++;
        return false;
      }

      // å¢åŠ è®¸å¯
      semaphore.increasePermits(1);
      if (semaphore.availablePermits() !== 2) {
        console.error('âŒ testDynamicPermits: å¢åŠ è®¸å¯åæ•°é‡é”™è¯¯');
        this.failed++;
        return false;
      }

      console.log('âœ… testDynamicPermits passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testDynamicPermits: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * æµ‹è¯•è¯»å†™é”
   */
  async testReadWriteLock(): Promise<boolean> {
    const rwLock: ReadWriteLock = new ReadWriteLock('test-rw');

    try {
      // æµ‹è¯•è¯»é”ï¼ˆåº”è¯¥å…è®¸å¤šä¸ªï¼‰
      await rwLock.acquireRead();
      await rwLock.acquireRead(); // ç¬¬äºŒä¸ªè¯»é”åº”è¯¥æˆåŠŸ

      // é‡Šæ”¾è¯»é”
      rwLock.releaseRead();
      rwLock.releaseRead();

      // æµ‹è¯•å†™é”
      await rwLock.acquireWrite();

      // å°è¯•è·å–è¯»é”ï¼ˆåº”è¯¥é˜»å¡ï¼‰
      const readAcquired: boolean = await Promise.race([
        rwLock.tryAcquireWithTimeout(50),
        new Promise<boolean>((resolve: (value: boolean) => void) => setTimeout(() => resolve(false), 100))
      ]);

      if (readAcquired) {
        console.error('âŒ testReadWriteLock: å†™é”æŒæœ‰æ—¶ä¸åº”è·å–è¯»é”');
        this.failed++;
        return false;
      }

      rwLock.releaseWrite();

      console.log('âœ… testReadWriteLock passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testReadWriteLock: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * æµ‹è¯•å¹¶å‘æ§åˆ¶å™¨
   */
  async testConcurrencyController(): Promise<boolean> {
    const controller: ConcurrencyController = new ConcurrencyController(2);

    try {
      // è·å–ä¿¡å·é‡
      await controller.acquire('resource1');

      // æ‰§è¡Œæ“ä½œ
      const result: string = await controller.execute('resource2', async () => {
        return 'executed';
      });

      if (result !== 'executed') {
        console.error('âŒ testConcurrencyController: æ‰§è¡Œç»“æœé”™è¯¯');
        this.failed++;
        return false;
      }

      // é‡Šæ”¾èµ„æº
      controller.release('resource1');

      // è·å–ç»Ÿè®¡
      const stats: SemaphoreStats[] = controller.getAllStats();
      if (stats.length !== 2) {
        console.error('âŒ testConcurrencyController: ç»Ÿè®¡æ•°é‡é”™è¯¯');
        this.failed++;
        return false;
      }

      console.log('âœ… testConcurrencyController passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testConcurrencyController: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
   */
  async testStatistics(): Promise<boolean> {
    const semaphore: Semaphore = new Semaphore({ permits: 2, name: 'test-stats' });

    try {
      // è·å–å¹¶é‡Šæ”¾å‡ æ¬¡
      await semaphore.acquire();
      semaphore.release();
      await semaphore.acquire();
      semaphore.release();

      const stats: SemaphoreStats = semaphore.getStats();

      if (stats.name !== 'Semaphore:test-stats') {
        console.error('âŒ testStatistics: åç§°é”™è¯¯');
        this.failed++;
        return false;
      }

      if (stats.totalPermits !== 2) {
        console.error('âŒ testStatistics: æ€»è®¸å¯æ•°é”™è¯¯');
        this.failed++;
        return false;
      }

      if (stats.acquiredCount !== 2) {
        console.error('âŒ testStatistics: è·å–æ¬¡æ•°é”™è¯¯');
        this.failed++;
        return false;
      }

      if (stats.releasedCount !== 2) {
        console.error('âŒ testStatistics: é‡Šæ”¾æ¬¡æ•°é”™è¯¯');
        this.failed++;
        return false;
      }

      console.log('âœ… testStatistics passed');
      this.passed++;
      return true;
    } catch (err) {
      const errorMessage: string = err instanceof Error ? err.message : String(err);
      console.error(`âŒ testStatistics: å¼‚å¸¸ ${errorMessage}`);
      this.failed++;
      return false;
    }
  }

  /**
   * è¿è¡Œæ‰€æœ‰æµ‹è¯•
   */
  async runAllTests(): Promise<boolean> {
    console.log('ğŸš€ Starting Semaphore tests...\n');

    await this.testBasicSemaphore();
    await this.testSemaphoreBlocking();
    await this.testTryAcquireWithTimeout();
    await this.testExecute();
    await this.testBatchOperations();
    await this.testDynamicPermits();
    await this.testReadWriteLock();
    await this.testConcurrencyController();
    await this.testStatistics();

    const total: number = this.passed + this.failed;
    console.log(`\nğŸ“Š Test Results: ${this.passed}/${total} tests passed`);

    if (this.failed > 0) {
      console.log(`âŒ ${this.failed} tests failed`);
    } else {
      console.log('âœ… All tests passed!');
    }

    return this.failed === 0;
  }
}

// å¯¼å‡ºæµ‹è¯•å®ä¾‹
const semaphoreTest: SemaphoreTest = new SemaphoreTest();
export default semaphoreTest;
