/**
 * SourceCleaner - ä¹¦æºæ¸…ç†å·¥å…·
 * ç”¨äºè‡ªåŠ¨ç¦ç”¨å¤±æ•ˆçš„ä¹¦æº
 */

import { Logger } from './Logger';
import { sourceHealthManager } from './SourceHealthManager';

export interface FailedSource {
  name: string;
  errorType: 'dns' | 'ssl' | 'http' | 'timeout' | 'unknown';
  errorMessage: string;
}

export class SourceCleaner {
  private static instance: SourceCleaner | null = null;
  private readonly TAG = 'SourceCleaner';

  // å·²çŸ¥çš„å¤±æ•ˆä¹¦æºåˆ—è¡¨(æ ¹æ®æ—¥å¿—åˆ†æ)
  private readonly PERMANENTLY_FAILED_SOURCES: FailedSource[] = [
    { name: 'é»‘å²©é˜…è¯»ç½‘', errorType: 'dns', errorMessage: 'åŸŸåè§£æå¤±è´¥' },
    { name: 'å…¥æ®“å¸ˆ', errorType: 'dns', errorMessage: 'åŸŸåè§£æå¤±è´¥' },
    { name: 'å·…å³°å°è¯´', errorType: 'ssl', errorMessage: 'SSLå†…éƒ¨é”™è¯¯' },
    { name: 'ç¬”è¶£é˜â‘¤', errorType: 'unknown', errorMessage: 'æ•°æ®æ¥æ”¶å¤±è´¥' }
  ];

  // éœ€è¦ä¼˜åŒ–åçˆ¬ç­–ç•¥çš„ä¹¦æº
  private readonly ANTI_SCRAPING_SOURCES: FailedSource[] = [
    { name: 'æ–°ç¬”è¶£å¡”', errorType: 'http', errorMessage: 'è®¿é—®è¢«æ‹’ç»(403)' },
    { name: 'çº¢äººå°è¯´', errorType: 'http', errorMessage: 'è®¿é—®è¢«æ‹’ç»(403)' },
    { name: 'è‚‰è‰²æ¼«ç”»', errorType: 'http', errorMessage: 'è®¿é—®è¢«æ‹’ç»(403)' }
  ];

  // SSLè¯ä¹¦é—®é¢˜çš„ä¹¦æº
  private readonly SSL_PROBLEMATIC_SOURCES: FailedSource[] = [
    { name: 'é€Ÿè¯»è°·å§', errorType: 'ssl', errorMessage: 'SSLè¯ä¹¦é”™è¯¯' },
    { name: 'ğŸ‰ å¤©åŸŸå°è¯´', errorType: 'ssl', errorMessage: 'SSLè¯ä¹¦é”™è¯¯' }
  ];

  private constructor() {}

  static getInstance(): SourceCleaner {
    if (!SourceCleaner.instance) {
      SourceCleaner.instance = new SourceCleaner();
    }
    return SourceCleaner.instance;
  }

  /**
   * è·å–æ‰€æœ‰éœ€è¦ç¦ç”¨çš„ä¹¦æºåç§°
   */
  getFailedSourceNames(): string[] {
    const failedSources: string[] = [];
    
    for (const source of this.PERMANENTLY_FAILED_SOURCES) {
      failedSources.push(source.name);
    }
    
    return failedSources;
  }

  /**
   * è·å–æ‰€æœ‰å¤±æ•ˆä¹¦æºçš„è¯¦ç»†ä¿¡æ¯
   */
  getAllFailedSources(): FailedSource[] {
    const allFailed: FailedSource[] = [];
    
    for (const source of this.PERMANENTLY_FAILED_SOURCES) {
      allFailed.push(source);
    }
    
    for (const source of this.SSL_PROBLEMATIC_SOURCES) {
      allFailed.push(source);
    }
    
    return allFailed;
  }

  /**
   * è®°å½•å¤±æ•ˆä¹¦æºåˆ°å¥åº·åº¦ç®¡ç†å™¨
   */
  recordFailedSources(): void {
    const allFailed = this.getAllFailedSources();
    
    for (const failed of allFailed) {
      // ä½¿ç”¨ä¹¦æºåç§°ä½œä¸ºä¸´æ—¶ID
      const tempId = `failed_${failed.name}`;
      sourceHealthManager.recordFailure(
        tempId,
        failed.name,
        '',
        failed.errorType,
        failed.errorMessage
      );
      
      Logger.info(this.TAG, `å·²è®°å½•å¤±æ•ˆä¹¦æº: ${failed.name}, é”™è¯¯ç±»å‹: ${failed.errorType}`);
    }
    
    Logger.info(this.TAG, `å…±è®°å½• ${allFailed.length} ä¸ªå¤±æ•ˆä¹¦æº`);
  }

  /**
   * è·å–éœ€è¦ä¼˜åŒ–åçˆ¬ç­–ç•¥çš„ä¹¦æº
   */
  getAntiScrapingSourceNames(): string[] {
    const sources: string[] = [];
    
    for (const source of this.ANTI_SCRAPING_SOURCES) {
      sources.push(source.name);
    }
    
    return sources;
  }

  /**
   * ç”Ÿæˆä¹¦æºæ¸…ç†æŠ¥å‘Š
   */
  generateCleanupReport(): string {
    const report: string[] = [];
    
    report.push('=== ä¹¦æºæ¸…ç†æŠ¥å‘Š ===');
    report.push('');
    report.push(`æ°¸ä¹…å¤±æ•ˆä¹¦æº (${this.PERMANENTLY_FAILED_SOURCES.length}ä¸ª):`);
    for (const source of this.PERMANENTLY_FAILED_SOURCES) {
      report.push(`  - ${source.name}: ${source.errorMessage}`);
    }
    
    report.push('');
    report.push(`SSLè¯ä¹¦é—®é¢˜ä¹¦æº (${this.SSL_PROBLEMATIC_SOURCES.length}ä¸ª):`);
    for (const source of this.SSL_PROBLEMATIC_SOURCES) {
      report.push(`  - ${source.name}: ${source.errorMessage}`);
    }
    
    report.push('');
    report.push(`éœ€è¦ä¼˜åŒ–åçˆ¬ç­–ç•¥çš„ä¹¦æº (${this.ANTI_SCRAPING_SOURCES.length}ä¸ª):`);
    for (const source of this.ANTI_SCRAPING_SOURCES) {
      report.push(`  - ${source.name}: ${source.errorMessage}`);
    }
    
    report.push('');
    report.push(`æ€»è®¡: ${this.getAllFailedSources().length} ä¸ªä¹¦æºéœ€è¦å¤„ç†`);
    
    return report.join('\n');
  }

  /**
   * æ¸…ç†æ‰€æœ‰å¤±æ•ˆä¹¦æº
   */
  async cleanupFailedSources(): Promise<void> {
    Logger.info(this.TAG, 'å¼€å§‹æ¸…ç†å¤±æ•ˆä¹¦æº...');
    
    // è®°å½•å¤±æ•ˆä¹¦æºåˆ°å¥åº·åº¦ç®¡ç†å™¨
    this.recordFailedSources();
    
    // ç”Ÿæˆæ¸…ç†æŠ¥å‘Š
    const report = this.generateCleanupReport();
    Logger.info(this.TAG, report);
    
    Logger.info(this.TAG, 'å¤±æ•ˆä¹¦æºæ¸…ç†å®Œæˆ');
  }
}

export const sourceCleaner = SourceCleaner.getInstance();
