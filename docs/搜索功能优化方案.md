# AstroRead 搜索功能模块优化方案

## 1. 概述

基于对当前搜索功能模块的深入分析，本方案提出针对五个关键方面的优化措施，旨在提升搜索准确性、效率和用户体验。

## 2. 搜索算法准确性与效率优化

### 2.1 问题分析
- 并发控制静态（固定5个并发，500ms间隔）
- 无搜索结果缓存机制
- 无结果后验证机制
- 解析效率不均

### 2.2 优化方案

#### 2.2.1 引入搜索结果缓存
```typescript
// 新增 SearchCache.ets
export class SearchCache {
  private cache: Map<string, CacheEntry> = new Map();
  private maxSize: number = 50;
  private ttl: number = 5 * 60 * 1000; // 5分钟

  set(key: string, books: Book[]): void {
    this.cleanup();
    if (this.cache.size >= this.maxSize) {
      this.evictOldest();
    }
    this.cache.set(key, {
      books: books,
      timestamp: Date.now()
    });
  }

  get(key: string): Book[] | null {
    const entry = this.cache.get(key);
    if (!entry) return null;
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    return entry.books;
  }

  private cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }
}
```

#### 2.2.2 动态书源优先级调整
修改 `BookSourceSearchEngine.ets` 中的书源排序逻辑：
```typescript
// 在 searchWithPaging 方法中
const sortedSources = enabledSources.sort((a: BookSource, b: BookSource) => {
  const scoreA = sourceHealthManager.getSourceScore(a.id);
  const scoreB = sourceHealthManager.getSourceScore(b.id);
  // 高质量书源优先
  return scoreB - scoreA;
});
```

#### 2.2.3 结果后验证与过滤
```typescript
// 新增 SearchResultValidator.ets
export class SearchResultValidator {
  static validateBook(book: Book, keyword: string): boolean {
    // 必填字段校验
    if (!book.name || !book.bookUrl) {
      return false;
    }
    
    // 关键词相似度计算
    const similarity = this.calculateSimilarity(book.name, keyword);
    if (similarity < 0.3) {
      return false;
    }
    
    // 字段标准化
    book.author = this.normalizeAuthor(book.author);
    book.intro = this.purifyIntro(book.intro);
    
    return true;
  }
  
  static calculateSimilarity(str1: string, str2: string): number {
    // 使用 Jaccard 相似度
    const set1 = new Set(str1.toLowerCase().split(''));
    const set2 = new Set(str2.toLowerCase().split(''));
    const intersection = new Set([...set1].filter(x => set2.has(x)));
    const union = new Set([...set1, ...set2]);
    return intersection.size / union.size;
  }
}
```

## 3. 解析错误与数据提取优化

### 3.1 问题分析
- 解析异常被静默忽略
- 提取字段未标准化
- JSONPath 支持有限
- 编码处理不当

### 3.2 优化方案

#### 3.2.1 增强错误日志与监控
修改 `ContentParser.ets`：
```typescript
static parseSearchResult(html: string, bookSource: BookSource): ParsedBookItem[] {
  try {
    // ... 现有代码
  } catch (error) {
    Logger.error(ContentParser.TAG, 
      `搜索解析异常 - 书源: ${bookSource.name}, ` +
      `规则类型: ${bookSource.ruleType}, ` +
      `错误: ${error instanceof Error ? error.message : String(error)}`
    );
    
    // 记录详细调试信息
    if (error instanceof Error && error.stack) {
      Logger.debug(ContentParser.TAG, `错误堆栈: ${error.stack}`);
    }
    
    // 返回部分成功结果时附带警告
    return [];
  }
}
```

#### 3.2.2 字段后处理增强
```typescript
// 在 ContentParser.ets 中添加字段后处理方法
private static normalizeAuthor(author: string): string {
  if (!author) return '未知作者';
  
  // 去除常见前缀
  const prefixes = ['作者:', '作者：', '著:', '著：', '作者 ', '作者 '];
  let normalized = author.trim();
  
  for (const prefix of prefixes) {
    if (normalized.startsWith(prefix)) {
      normalized = normalized.substring(prefix.length).trim();
    }
  }
  
  return normalized || '未知作者';
}

private static purifyIntro(intro: string): string {
  if (!intro) return '';
  
  // 去除 HTML 标签
  let purified = intro.replace(/<[^>]+>/g, '');
  
  // 解码 HTML 实体
  purified = EntityDecoder.decode(purified);
  
  // 去除多余空格和换行
  purified = purified.replace(/\s+/g, ' ').trim();
  
  // 截断过长内容
  if (purified.length > 200) {
    purified = purified.substring(0, 200) + '...';
  }
  
  return purified;
}
```

#### 3.2.3 增强 JSONPath 支持
```typescript
// 新增 JsonPathEngine.ets
export class JsonPathEngine {
  static evaluate(data: any, path: string): any {
    // 支持基本 JSONPath 语法
    // $..* - 递归下降
    // [*] - 通配符
    // [?()] - 过滤器（简化版）
    
    if (!path || path === '$' || path === '$.') {
      return data;
    }
    
    // 处理递归下降
    if (path.startsWith('$..')) {
      return this.deepSearch(data, path.substring(3));
    }
    
    // 处理通配符
    if (path.includes('[*]')) {
      return this.wildcardSearch(data, path);
    }
    
    // 默认使用现有逻辑
    return ContentParser.resolveJsonPath(data, path);
  }
}
```

## 4. 搜索结果排序逻辑优化

### 4.1 问题分析
- 相关性评分简单
- 未考虑关键词匹配度
- 未融合书源质量
- 去重逻辑简单

### 4.2 优化方案

#### 4.2.1 增强相关性评分
修改 `SearchResult.ets` 中的 `calculateRelevanceScore` 方法：
```typescript
private calculateRelevanceScore(book: Book, keyword?: string): number {
  let score = 0;
  
  // 基础分
  if (book.cover && book.cover.length > 0) {
    score += 10;
  }
  if (book.intro && book.intro.length > 0) {
    score += 5;
  }
  if (book.author && book.author !== '未知作者') {
    score += 5;
  }
  if (book.wordCount && book.wordCount > 0) {
    score += Math.min(book.wordCount / 100000, 10);
  }
  
  // 关键词匹配度（如果提供关键词）
  if (keyword) {
    const name = book.name.toLowerCase();
    const kw = keyword.toLowerCase();
    
    if (name === kw) {
      score += 50; // 完全匹配
    } else if (name.startsWith(kw)) {
      score += 30; // 前缀匹配
    } else if (name.includes(kw)) {
      score += 20; // 包含匹配
    }
    
    // 简介中包含关键词
    if (book.intro && book.intro.toLowerCase().includes(kw)) {
      score += 5;
    }
  }
  
  // 书源质量权重
  const sourceScore = sourceHealthManager.getSourceScore(book.bookSourceId);
  const sourceWeight = sourceScore / 100; // 转换为 0-1 权重
  
  return score * (0.7 + 0.3 * sourceWeight); // 70%内容分 + 30%书源质量
}
```

#### 4.2.2 改进去重逻辑
```typescript
private deduplicateBooks(books: Book[]): Book[] {
  const seen = new Map<string, Book>();
  
  for (let i = 0; i < books.length; i++) {
    const book = books[i];
    
    // 使用书名+作者+URL作为唯一标识
    const key = `${book.name}_${book.author || ''}_${book.bookUrl}`.toLowerCase().trim();
    
    if (!seen.has(key)) {
      seen.set(key, book);
    } else {
      // 如果 URL 相同，合并来源信息
      const existing = seen.get(key)!;
      if (existing.bookUrl === book.bookUrl) {
        // 保留更完整的信息
        if (!existing.cover && book.cover) existing.cover = book.cover;
        if (!existing.intro && book.intro) existing.intro = book.intro;
        if (!existing.author && book.author) existing.author = book.author;
      }
    }
  }
  
  return Array.from(seen.values());
}
```

## 5. 特殊字符、模糊查询、多关键词组合优化

### 5.1 问题分析
- 关键词编码统一
- 无内置模糊查询
- 多关键词处理简单
- 无高级语法支持

### 5.2 优化方案

#### 5.2.1 书源自定义编码方式
扩展 `BookSource` 模型：
```typescript
// 在 BookSource.ets 中添加
export interface BookSource {
  // ... 现有字段
  keywordEncoding?: 'urlencode' | 'base64' | 'double-urlencode' | 'none';
  keywordSeparator?: string; // 多关键词分隔符
  advancedQuerySupport?: boolean; // 是否支持高级查询
}
```

#### 5.2.2 用户输入解析器
```typescript
// 新增 SearchQueryParser.ets
export class SearchQueryParser {
  static parse(query: string): ParsedQuery {
    const result: ParsedQuery = {
      original: query,
      keywords: [],
      exclude: [],
      exactPhrases: [],
      fieldQueries: new Map(),
      isAdvanced: false
    };
    
    // 解析双引号内的短语
    const phraseMatches = query.match(/"[^"]+"/g);
    if (phraseMatches) {
      result.exactPhrases = phraseMatches.map(m => m.slice(1, -1));
      query = query.replace(/"[^"]+"/g, '');
    }
    
    // 解析减号排除
    const excludeMatches = query.match(/-\w+/g);
    if (excludeMatches) {
      result.exclude = excludeMatches.map(m => m.slice(1));
      query = query.replace(/-\w+/g, '');
    }
    
    // 解析字段限定
    const fieldMatches = query.match(/(author|title|intro):\s*[^\s]+/g);
    if (fieldMatches) {
      for (const match of fieldMatches) {
        const [field, value] = match.split(':');
        result.fieldQueries.set(field.trim(), value.trim());
      }
      query = query.replace(/(author|title|intro):\s*[^\s]+/g, '');
    }
    
    // 剩余部分作为普通关键词
    result.keywords = query.trim().split(/\s+/).filter(k => k.length > 0);
    result.isAdvanced = result.exactPhrases.length > 0 || 
                       result.exclude.length > 0 || 
                       result.fieldQueries.size > 0;
    
    return result;
  }
}
```

#### 5.2.3 模糊查询支持
```typescript
// 扩展 SearchEnhancer.ets
class SearchEnhancer {
  // ... 现有代码
  
  fuzzySearch(books: Book[], query: string, threshold: number = 0.6): Book[] {
    const results: Array<{book: Book, score: number}> = [];
    
    for (const book of books) {
      const score = this.calculateFuzzyMatchScore(book.name, query);
      if (score >= threshold) {
        results.push({book, score});
      }
    }
    
    // 按相似度排序
    results.sort((a, b) => b.score - a.score);
    return results.map(r => r.book);
  }
  
  private calculateFuzzyMatchScore(text: string, query: string): number {
    // 使用编辑距离计算相似度
    const distance = this.calculateLevenshteinDistance(text.toLowerCase(), query.toLowerCase());
    const maxLength = Math.max(text.length, query.length);
    
    if (maxLength === 0) return 1.0;
    return 1.0 - distance / maxLength;
  }
}
```

## 6. 搜索响应速度优化

### 6.1 问题分析
- 串行+并发模式
- 网络超时固定
- 封面同步加载
- 无渐进式结果展示

### 6.2 优化方案

#### 6.2.1 渐进式结果返回
修改 `BookSourceSearchEngine.ets`：
```typescript
async searchWithPaging(
  sources: BookSource[],
  options: SearchOptions,
  progressCallback?: SearchProgressCallback,
  bookFoundCallback?: BookFoundCallback,
  onPartialResult?: (books: Book[]) => void // 新增回调
): Promise<PagedSearchResult> {
  // ... 现有代码
  
  // 在搜索结果回调中添加
  if (bookFoundCallback && newBooks.length > 0) {
    bookFoundCallback(newBooks, this.cloneSearchProgress(progress));
  }
  
  // 新增：实时返回部分结果
  if (onPartialResult && newBooks.length > 0) {
    const allBooksSoFar = resultBuilder.getAllBooks(); // 需要新增方法
    onPartialResult(allBooksSoFar);
  }
  
  // ... 现有代码
}
```

#### 6.2.2 动态超时与失败快速返回
```typescript
private async executeSearchWithTimeout(
  source: BookSource, 
  keyword: string, 
  page: number
): Promise<SearchResult> {
  const timeout = this.getAdaptiveTimeout(source);
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const result = await Promise.race([
      this.searchSingleSource(source, keyword, page, controller.signal),
      new Promise<never>((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), timeout)
      )
    ]);
    
    clearTimeout(timeoutId);
    return result;
  } catch (error) {
    clearTimeout(timeoutId);
    this.recordFailure(source, error);
    return this.createEmptyResult(source, error.message);
  }
}

private getAdaptiveTimeout(source: BookSource): number {
  const stats = sourceHealthManager.getSourceStats(source.id);
  if (!stats || stats.requestCount < 5) {
    return DEFAULT_TIMEOUT;
  }
  
  // 基于历史响应时间动态调整
  const adaptiveTimeout = Math.min(
    stats.avgResponseTime * 2 + 2000, // 平均响应时间的2倍 + 2秒缓冲
    MAX_TIMEOUT
  );
  
  return adaptiveTimeout;
}
```

#### 6.2.3 封面懒加载
在搜索结果展示组件中：
```typescript
// 使用 Image 组件的 lazyLoad 属性
Image(src: book.cover)
  .lazyLoad(true)
  .placeholder($r('app.media.placeholder'))
  .onAppear(() => {
    // 图片进入可视区域时加载
  })
```

## 7. 实施计划

### 7.1 短期优化（1-2周）
1. **实现搜索结果缓存** - 减少重复搜索开销
2. **添加渐进式结果展示** - 提升用户体验
3. **增强错误日志** - 便于问题排查
4. **优化去重逻辑** - 避免误删不同书籍

### 7.2 中期优化（1个月）
1. **实现动态书源优先级** - 基于历史表现调整
2. **增强相关性评分** - 考虑关键词匹配度
3. **添加字段后处理** - 标准化作者、简介等字段
4. **实现封面懒加载** - 提升列表滚动性能

### 7.3 长期优化（2-3个月）
1. **支持高级搜索语法** - 引号、减号、字段限定
2. **实现本地模糊查询** - 拼音、首字母匹配
3. **添加用户偏好学习** - 基于点击历史调整权重
4. **优化 JSONPath 支持** - 支持更复杂的查询语法

## 8. 预期效果

### 8.1 性能提升
- 搜索响应时间减少 30-50%
- 重复搜索命中缓存时响应时间减少 90%
- 内存使用优化，减少重复解析开销

### 8.2 准确性提升
- 搜索结果相关性提高 20-30%
- 无效结果过滤率提高 40-50%
- 书源质量识别准确率提高 60%

### 8.3 用户体验改善
- 搜索结果实时展示，无需等待所有书源完成
- 支持更灵活的搜索语法
- 搜索结果排序更符合用户预期
- 错误提示更清晰，便于问题排查

## 9. 风险与缓解措施

### 9.1 技术风险
- **性能影响**：新增验证逻辑可能增加计算开销
  - 缓解：使用异步处理和批量操作
- **兼容性问题**：修改可能影响现有书源
  - 缓解：保持向后兼容，逐步迁移

### 9.2 业务风险
- **搜索结果变化**：新算法可能导致排序变化
  - 缓解：A/B 测试，收集用户反馈
- **缓存一致性问题**：缓存可能导致结果不及时
  - 缓解：合理设置 TTL，提供手动刷新

## 10. 监控与评估

### 10.1 关键指标
- 平均搜索响应时间
- 缓存命中率
- 书源成功率/失败率
- 用户点击率/满意度

### 10.2 评估方法
- A/B 测试对比新旧版本
- 用户反馈收集
- 性能监控数据分析
- 错误日志分析

通过以上优化措施，AstroRead 的搜索功能将在准确性、效率和用户体验方面得到显著提升。