# 解析模块代码复用与整合方案

## 一、模块架构概览

### 1.1 文件结构

```
entry/src/main/ets/
├── interfaces/                      # 接口定义层
│   ├── IParser.ets                  # 通用解析器接口（JSON/XML/HTML/CSV）
│   └── IContentParser.ets           # 书源内容解析接口
│
├── core/                            # 核心解析层
│   ├── ParserAdapter.ets            # 解析器适配器基类
│   ├── ParserError.ets              # 统一错误处理
│   ├── ParserFacade.ets             # 通用解析器门面
│   ├── AstroReadFacade.ets          # 应用统一门面
│   ├── index.ets                    # 模块导出入口
│   └── adapters/                    # 解析器适配器
│       ├── JSONParserAdapter.ets
│       ├── XMLParserAdapter.ets
│       ├── HTMLParserAdapter.ets
│       └── CSVParserAdapter.ets
│
└── utils/                           # 工具层
    ├── HTMLParser.ets               # 书源HTML解析器
    ├── ContentParser.ets            # 书源内容解析
    ├── RuleEngine.ets               # 规则引擎
    ├── BookSourceManager.ets        # 书源管理
    └── BookSourceSearchEngine.ets   # 书源搜索引擎
```

### 1.2 依赖关系图

```
┌─────────────────────────────────────────────────────────────────┐
│                      应用层 (UI Components)                      │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     AstroReadFacade                              │
│  统一应用入口 - 整合解析、搜索、网络、书源管理                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 方法: parseHtml, searchBooks, importSources, get/post   │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────┬───────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
        ▼                     ▼                     ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ BookSource    │   │ ContentParser │   │ RuleEngine    │
│ Manager       │   │               │   │               │
│               │   │               │   │               │
│ 书源CRUD      │   │ 书源内容解析   │   │ 规则执行引擎   │
└───────┬───────┘   └───────┬───────┘   └───────┬───────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            │
                            ▼
                  ┌─────────────────┐
                  │   HTMLParser    │
                  │   (utils层)      │
                  │   书源专用解析    │
                  └─────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      ParserFacade                                │
│  通用解析器门面 - JSON/XML/HTML/CSV 格式解析                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 方法: parse, parseSync, validate, format, parseBatch    │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────┬───────────────────────────────────┘
                              │
        ┌─────────┬───────────┼───────────┬─────────┐
        ▼         ▼           ▼           ▼         ▼
┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐
│ JSON      │ │ XML       │ │ HTML      │ │ CSV       │
│ Adapter   │ │ Adapter   │ │ Adapter   │ │ Adapter   │
└─────┬─────┘ └─────┬─────┘ └─────┬─────┘ └─────┬─────┘
      │             │             │             │
      └─────────────┴──────┬──────┴─────────────┘
                           │
                           ▼
                 ┌─────────────────┐
                 │ ParserAdapter   │
                 │ (抽象基类)       │
                 │ - 输入验证       │
                 │ - 选项合并       │
                 │ - 错误处理       │
                 │ - 缓存支持       │
                 └────────┬────────┘
                          │
                          ▼
                 ┌─────────────────┐
                 │   IParser       │
                 │   接口定义       │
                 └─────────────────┘
```

## 二、接口规范

### 2.1 通用解析器接口 (IParser.ets)

```typescript
// 解析器类型枚举
export enum ParserType {
  JSON = 'json',
  XML = 'xml',
  HTML = 'html',
  CSV = 'csv',
  TEXT = 'text',
  BINARY = 'binary'
}

// 解析状态枚举
export enum ParseStatus {
  SUCCESS = 'success',
  PARTIAL = 'partial',
  FAILED = 'failed',
  PENDING = 'pending'
}

// 解析选项
export interface ParseOptions {
  encoding?: string;        // 编码格式
  strict?: boolean;         // 严格模式
  maxDepth?: number;        // 最大深度
  timeout?: number;         // 超时时间
  cacheKey?: string;        // 缓存键
  skipCache?: boolean;      // 跳过缓存
  customRules?: Record<string, string>;  // 自定义规则
}

// 解析结果
export interface ParseResult<T = object> {
  data: T;                  // 解析数据
  status: ParseStatus;      // 解析状态
  errors: ParseErrorInfo[]; // 错误列表
  warnings: ParseWarningInfo[]; // 警告列表
  metadata: ParseMetadata;  // 元数据
  raw?: string;             // 原始内容
}

// 解析器接口
export interface IParser<T = object, R = ParseResult<T>> {
  readonly type: ParserType;
  readonly version: string;
  readonly supportedExtensions: string[];

  parse(content: string | ArrayBuffer, options?: ParseOptions): Promise<R>;
  parseSync(content: string | ArrayBuffer, options?: ParseOptions): R;
  validate(content: string | ArrayBuffer, options?: ParseOptions): ValidationResult;
  format(data: T, options?: FormatOptions): string;
  canParse(content: string | ArrayBuffer, hint?: string): boolean;
}
```

### 2.2 书源内容解析接口 (IContentParser.ets)

```typescript
// 书源模型
export interface BookSource {
  id: string;
  name: string;
  url: string;
  enabled: boolean;
  searchUrl?: string;
  searchRule?: SearchRule;
  chapterRule?: ChapterRule;
  contentRule?: ContentRule;
  ruleType?: 'xpath' | 'jsonpath' | 'regex';
}

// 书源内容解析器接口
export interface IBookSourceParser {
  parseSearchResult(html: string, bookSource: BookSource): ParsedBookItem[];
  parseChapterList(html: string, bookSource: BookSource): ParsedChapterItem[];
  parseChapterContent(html: string, bookSource: BookSource): string;
  purifyContent(content: string, replaceRule?: ReplaceRuleConfig): string;
}

// 规则引擎接口
export interface IRuleEngine {
  parseRule(rule: string, html: string): string;
  parseRuleList(rule: string, html: string): string[];
  parseSearchUrl(searchUrl: string, keyword: string, page: number, baseUrl: string): ParsedUrl;
  setContext(context: Partial<RuleContext>): void;
  getContext(): RuleContext;
}

// 搜索引擎接口
export interface ISearchEngine {
  search(sources: BookSource[], options: SearchOptions): Promise<SearchResult[]>;
  searchSingleSource(source: BookSource, key: string, page: number): Promise<SearchResult>;
  aggregateResults(results: SearchResult[]): Book[];
  setConfig(config: Partial<SearchConfig>): void;
}

// 书源管理器接口
export interface IBookSourceManager {
  importSources(input: string): Promise<BookSource[]>;
  searchBooks(keyword: string, options?: Partial<SearchOptions>): Promise<SearchBooksResult>;
  getAllSources(): BookSource[];
  getEnabledSources(): BookSource[];
  addSource(source: BookSource): void;
  removeSource(id: string): void;
  updateSource(source: BookSource): void;
  exportSources(sources?: BookSource[]): string;
}
```

## 三、统一代码引用机制

### 3.1 标准导入方式

```typescript
// 方式一：从模块入口导入（推荐）
import ParserFacade, { 
  ParserType, 
  ParseStatus,
  Parsers 
} from '../core';

// 方式二：按需导入
import { JSONParserAdapter } from '../core/adapters/JSONParserAdapter';
import { XMLParserAdapter } from '../core/adapters/XMLParserAdapter';

// 方式三：导入应用门面
import AstroReadFacade from '../core/AstroReadFacade';
```

### 3.2 使用示例

#### 通用解析器使用

```typescript
// 获取解析器门面实例
const parser = ParserFacade.getInstance();

// 解析 JSON
const jsonResult = await parser.parseJSON('{"name": "张三"}');

// 解析 XML
const xmlResult = await parser.parseXML('<root><item/></root>');

// 解析 HTML
const htmlResult = await parser.parseHTML('<div class="test">内容</div>');

// 解析 CSV
const csvResult = await parser.parseCSV('name,age\n张三,25');

// 自动检测格式
const autoResult = await parser.parse(content);

// 批量解析
const batchResults = await parser.parseBatch([
  { content: '{"a": 1}', type: ParserType.JSON },
  { content: '<root/>', type: ParserType.XML }
]);
```

#### 书源功能使用

```typescript
// 获取应用门面实例
const facade = AstroReadFacade.getInstance();

// 导入书源
const sources = await facade.importSources(jsonString);

// 搜索书籍
const searchResult = await facade.searchBooks('斗罗大陆');

// 解析搜索结果
const books = facade.parseSearchResult(html, source);

// 解析章节列表
const chapters = facade.parseChapterList(html, source);

// 解析章节内容
const content = facade.parseChapterContent(html, source);

// 执行规则
const result = facade.executeRule('//div[@class="content"]', html);
```

### 3.3 模块导出规范 (index.ets)

```typescript
// 导出所有接口类型
export * from '../interfaces/IParser';
export * from '../interfaces/IContentParser';

// 导出错误处理
export * from './ParserError';

// 导出适配器基类
export * from './ParserAdapter';

// 导出门面类
export * from './ParserFacade';

// 导出具体适配器
export { JSONParserAdapter } from './adapters/JSONParserAdapter';
export { XMLParserAdapter } from './adapters/XMLParserAdapter';
export { HTMLParserAdapter } from './adapters/HTMLParserAdapter';
export { CSVParserAdapter, CSVParseOptions } from './adapters/CSVParserAdapter';

// 导出预实例化解析器
import ParserFacade from './ParserFacade';
import { JSONParserAdapter } from './adapters/JSONParserAdapter';
import { XMLParserAdapter } from './adapters/XMLParserAdapter';
import { HTMLParserAdapter } from './adapters/HTMLParserAdapter';
import { CSVParserAdapter } from './adapters/CSVParserAdapter';

export const Parsers = {
  json: new JSONParserAdapter(),
  xml: new XMLParserAdapter(),
  html: new HTMLParserAdapter(),
  csv: new CSVParserAdapter()
};

export default ParserFacade;
```

## 四、各模块输入输出参数

### 4.1 解析器适配器

| 适配器 | 输入类型 | 输出类型 | 特殊选项 |
|--------|----------|----------|----------|
| JSONParserAdapter | `string` | `ParseResult<JsonValue>` | `strict: boolean` |
| XMLParserAdapter | `string` | `ParseResult<XmlNode>` | `maxDepth: number` |
| HTMLParserAdapter | `string` | `ParseResult<HtmlNode>` | - |
| CSVParserAdapter | `string` | `ParseResult<CsvResult>` | `delimiter`, `hasHeader` |

### 4.2 门面类方法

#### ParserFacade

| 方法 | 输入 | 输出 | 说明 |
|------|------|------|------|
| `parse<T>()` | `content, type?, options?` | `Promise<ParseResult<T>>` | 通用解析 |
| `parseSync<T>()` | `content, type?, options?` | `ParseResult<T>` | 同步解析 |
| `parseJSON<T>()` | `content, options?` | `Promise<ParseResult<T>>` | JSON解析 |
| `parseXML()` | `content, options?` | `Promise<ParseResult<XmlNode>>` | XML解析 |
| `parseHTML()` | `content, options?` | `Promise<ParseResult<HtmlNode>>` | HTML解析 |
| `parseCSV()` | `content, options?` | `Promise<ParseResult<CsvResult>>` | CSV解析 |
| `validate()` | `content, type?, options?` | `ValidationResult` | 验证内容 |
| `format()` | `data, type, options?` | `string` | 格式化数据 |
| `parseBatch()` | `items[]` | `Promise<ParseResult[]>` | 批量解析 |

#### AstroReadFacade

| 方法 | 输入 | 输出 | 说明 |
|------|------|------|------|
| `parseHtml()` | `html, rule` | `string[]` | HTML解析 |
| `parseSearchResult()` | `html, source` | `ParsedBookItem[]` | 解析搜索结果 |
| `parseChapterList()` | `html, source` | `ParsedChapterItem[]` | 解析章节列表 |
| `parseChapterContent()` | `html, source` | `string` | 解析章节内容 |
| `importSources()` | `input` | `Promise<BookSource[]>` | 导入书源 |
| `searchBooks()` | `keyword, options?` | `Promise<SearchBooksResult>` | 搜索书籍 |
| `get/post()` | `url, config?` | `Promise<string>` | 网络请求 |

## 五、代码复用策略

### 5.1 共享工具类

```typescript
// 建议创建共享工具类
export class EntityDecoder {
  private static readonly entities: Record<string, string> = {
    '&lt;': '<', '&gt;': '>', '&amp;': '&',
    '&quot;': '"', '&apos;': "'", '&nbsp;': ' '
  };

  static decode(text: string): string { ... }
  static encode(text: string): string { ... }
}

export class PositionTracker {
  index: number = 0;
  advance(count: number): void { ... }
}
```

### 5.2 缓存策略

```typescript
// 两级缓存架构
// Level 1: ParserFacade 级别缓存（跨解析器共享）
// Level 2: CachingParserAdapter 级别缓存（解析器内部）

// 缓存键生成规则
const cacheKey = `${type}_${hash}_${size}_${JSON.stringify(customRules)}`;

// 缓存淘汰策略：LRU（最近最少使用）
```

### 5.3 错误处理统一

```typescript
// 统一错误类型
export enum ParserErrorCode {
  UNKNOWN = 'PARSER_UNKNOWN',
  INVALID_INPUT = 'PARSER_INVALID_INPUT',
  EMPTY_INPUT = 'PARSER_EMPTY_INPUT',
  SYNTAX_ERROR = 'PARSER_SYNTAX_ERROR',
  TIMEOUT = 'PARSER_TIMEOUT',
  DEPTH_EXCEEDED = 'PARSER_DEPTH_EXCEEDED',
  // ...
}

// 错误创建工厂方法
ParserError.syntaxError(type, message, line?, column?, context?)
ParserError.invalidInput(type, message?)
ParserError.emptyInput(type)
ParserError.timeout(type, timeout)
```

## 六、版本控制与分支管理策略

### 6.1 分支策略

```
main (稳定分支)
  │
  ├── develop (开发分支)
  │     │
  │     ├── feature/parser-optimization (功能分支)
  │     ├── feature/new-adapter (功能分支)
  │     └── bugfix/xml-parser-fix (修复分支)
  │
  └── release/v1.x.x (发布分支)
```

### 6.2 开发规范

1. **功能开发**: 从 `develop` 创建 `feature/*` 分支
2. **Bug修复**: 从 `develop` 创建 `bugfix/*` 分支
3. **发布**: 从 `develop` 合并到 `release/*`，测试后合并到 `main`

### 6.3 提交规范

```
feat(parser): 添加新的解析器适配器
fix(xml): 修复XML解析器嵌套标签问题
refactor(facade): 重构门面类缓存机制
test(csv): 添加CSV解析器单元测试
docs(readme): 更新API文档
```

## 七、测试策略

### 7.1 单元测试覆盖

```typescript
// 测试文件结构
core/__tests__/
├── ParserFacade.test.ets      # 门面测试
├── adapters/
│   ├── JSONParserAdapter.test.ets
│   ├── XMLParserAdapter.test.ets
│   ├── HTMLParserAdapter.test.ets
│   └── CSVParserAdapter.test.ets
└── ParserError.test.ets       # 错误处理测试
```

### 7.2 测试用例模板

```typescript
@describe('JSONParserAdapter')
testJSONParser(): void {
  @it('should parse valid JSON')
  testValidJSON(): void {
    const content = '{"name": "张三"}';
    const result = parser.parseSync(content, ParserType.JSON);
    
    expect(result.status).toBe(ParseStatus.SUCCESS);
    expect(result.data).toEqual({ name: '张三' });
  });

  @it('should handle errors correctly')
  testErrors(): void {
    const content = '{"name": "张三"';
    const result = parser.parseSync(content, ParserType.JSON);
    
    expect(result.status).toBe(ParseStatus.FAILED);
    expect(result.errors[0].code).toBe(ParserErrorCode.SYNTAX_ERROR);
  });
}
```

### 7.3 集成测试

```typescript
// 测试门面与适配器的集成
@it('should integrate all parsers correctly')
async testIntegration(): Promise<void> {
  const facade = ParserFacade.getInstance();
  
  // 测试所有解析器
  const results = await facade.parseBatch([
    { content: '{"a": 1}', type: ParserType.JSON },
    { content: '<root/>', type: ParserType.XML },
    { content: '<div/>', type: ParserType.HTML },
    { content: 'a,b\n1,2', type: ParserType.CSV }
  ]);
  
  expect(results.every(r => r.status === ParseStatus.SUCCESS)).toBe(true);
});
```

## 八、性能优化建议

### 8.1 缓存优化

- 使用 LRU 缓存淘汰策略
- 设置合理的 TTL（默认5分钟）
- 支持缓存预热和清理

### 8.2 解析优化

- 大文件分块解析
- 深度限制防止栈溢出
- 异步解析避免阻塞UI

### 8.3 内存优化

- 及时释放临时对象
- 使用对象池复用
- 避免深拷贝

---

**文档版本**: v1.0.0  
**最后更新**: 2026-02-17
